<?php

/**
 * @file
 * This module provides a way for users to reply to webform submissions within the CMS.
 * @author Paul Rowell <www.paulrowell.com>
 */

/**
 * Implements hook_help().
 */
function webform_email_reply_help($path, $arg) {
  switch ($path) {
    case "admin/help#webform_email_reply":
      $return_value = "<p>" . t("This module provides a way for users to reply to webform submissions within the CMS.") . '<br />';
      $return_value .= t("Permissions can be set to allow users to reply to all webform submissions or only those on a node the user has created.") . '<p>';
      $return_value .= "<p>" . t("All emails sent are stored in the database and can be viewed from the submission.") . '</p>';
      return $return_value;
      break;
  }
}


/**
 * Implements hook_webform_submission_actions().
 */
function webform_email_reply_webform_submission_actions($node, $submission) {
  if (webform_email_reply_access($node, $submission)) {
    $actions['reply'] = array(
      'title' => t('Email reply'),
      'href' => 'node/' . $node->nid . '/submission/' . $submission->sid . '/reply',
      'query' => drupal_get_destination(),
    );
    // only display link if there are replies
    $replies = webform_email_reply_exists($node->nid, $submission->sid);
    if ($replies) {
      // get number of replies
      $count = count($replies);
      $actions['previous_replies'] = array(
        'title' => format_plural($count, '1 previous reply', '@count previous replies'),
        'href' => 'node/' . $node->nid . '/submission/' . $submission->sid . '/reply/previous',
        'query' => drupal_get_destination(),
      );
    }
  }
  return $actions;
}

/**
 * Implements hook_menu().
 */
function webform_email_reply_menu() {
  $items = array();

  $items['node/%webform_menu/submission/%webform_menu_submission/reply'] = array(
    'title' => 'Reply to submission',
    'load arguments' => array(1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_email_reply_form', 1, 3),
    'access callback' => 'webform_email_reply_access',
    'access arguments' => array(1, 3),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%webform_menu/submission/%webform_menu_submission/reply/previous'] = array(
    'title' => 'Previous replies to submission',
    'load arguments' => array(1),
    'page callback' => 'webform_email_reply_previous',
    'page arguments' => array(1, 3),
    'access callback' => 'webform_email_reply_access',
    'access arguments' => array(1, 3),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function webform_email_reply_theme() {

  $theme = array(
    'webform_replies_table' => array(
      'variables' => array('node' => $node, 'submissions' => $submissions, 'replies' => $replies),
    )
  );

  return $theme;
}

/**
 * Implements hook_permission().
 */
function webform_email_reply_permission() {
  $permissions = array(
    'send email replies to all webforms' => array(
      'title' => t('View and send email replies to all webforms'),
      'description' => t('Allows user to view and send emails in reply to any webform. Generally an administrative permission.'),
    ),
    'send email replies to own webforms' => array(
      'title' => t('View and send email replies to own webforms'),
      'description' => t('Allows user to view and send emails in reply to a webform the author has created. Generally an administrative permission.'),
    ),
  );

  return $permissions;
}

/**
 * A function to check if a user hass access to email reply to a webform.
 * Cloned from webform.module
 *
 * @param type $node
 *    The node for which this webform was submitted.
 * @param type $submission
 *    The submission to email reply to.
 */
function webform_email_reply_access($node, $submission) {
  global $user;
  $account = isset($account) ? $account : $user;

  $reply_all = user_access('send email replies to all webforms', $account);
  $reply_own = isset($submission) && user_access('send email replies to own webforms', $account) && (($account->uid && $account->uid == $submission->uid) || isset($_SESSION['webform_submission'][$submission->sid]));

  return $reply_all || $reply_own;
}

/**
 * Form to send an email reply
 *
 * @param $form
 *   The new form array.
 * @param $form_state
 *   The current form state.
 * @param $node
 *   The node for which this webform was submitted.
 * @param $submission
 *   The submission to email reply to (from webform_submitted_data).
 */
function webform_email_reply_form($form, $form_state, $node, $submission) {
  webform_set_breadcrumb($node, $submission);

  //  Set the correct page title.
  drupal_set_title(t('Reply to ' . webform_submission_title($node, $submission)));

  //  Keep the NID and SID in the same location as the webform_client_form().
  //  This helps mollom identify the same fields when deleting a submission.
  $form['#tree'] = TRUE;
  $form['#suffix'] = '<h2>Submission</h2>' . webform_submission_render($node, $submission, NULL, 'html');
  $form['details']['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['details']['sid'] = array(
    '#type' => 'value',
    '#value' => $submission->sid,
  );
  $form['details']['email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email'),
    '#description' => t('The email address(es) to send to. Multiple emails should be seperated by a comma, with no spaces.'),
    '#required' => TRUE,
  );
  $form['details']['subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject'),
    '#default_value' => t('RE: ' . $node->title),
    '#required' => TRUE,
  );
  $form['details']['message'] = array(
    '#type' => 'textarea',
    '#title' => t('Message'),
    '#required' => TRUE,
    '#format' => 'full_html',
  );

  if (isset($_GET['destination'])) {
    $destination = $_GET['destination'];
  }
  else {
    $destination = 'node/' . $node->nid . '/submission/' . $submission->sid;
  }

  return confirm_form($form, NULL, $destination, '', t('Send'), t('Cancel'));
}

/**
 * Validation of email reply.
 *
 * @param $form
 *   The new form array.
 * @param $form_state
 *   The current form state.
 */
function webform_email_reply_form_validate($form, &$form_state) {
  // check each email
  $valid_email = explode(',', $form_state['values']['details']['email']);
  foreach ($valid_email as $email) {
    if (!valid_email_address($email)) {
      form_set_error('details][email', t('The email address, %email, is not valid. Please enter a valid email address.', array('%email' => $email)));
    }
  }
}

/**
 * Confirmation of email reply.
 *
 * @param $form
 *   The new form array.
 * @param $form_state
 *   The current form state.
 */
function webform_email_reply_form_submit($form, &$form_state) {

  $nid = $form_state['values']['details']['nid'];
  $sid = $form_state['values']['details']['sid'];

  $emails = explode(',', $form_state['values']['details']['email']);
  $body = $form_state['values']['details']['message'];
  $subject = $form_state['values']['details']['subject'];
  $params = array(
    'body' => $body,
    'subject' => $subject,
  );

  // Send each emails individually
  foreach ($emails as $email) {
    if (drupal_mail('webform_submission_reply', 'message_key', $email, language_default(), $params, $from, TRUE)) {
      drupal_set_message(t('Email sent to %email.', array('%email' => $email)));
      // insert the values into the database
      webform_email_reply_insert($form_state['values']['details']);
    }
    else {
      drupal_set_message(t('There was an error sending the email to %email, please contact the site admin.', array('%email' => $email)));
    }
  }
  $form_state['redirect'] = 'node/' . $nid . '/submission/' . $sid;
}

/**
 * Implements hook_mail().
 */
function webform_email_reply_mail($key, &$message, $params) {

  if (isset($params['subject'])) {
    $message['subject'] = $params['subject'];
  }
  if (isset($params['body'])) {
    $message['body'][] = $params['body'];
  }
  if (isset($params['headers']) && is_array($params['headers'])) {
    $message['headers'] += $params['headers'];
  }
}

/**
 * Function to insert the email into the database.
 *
 * @param type $data
 *   The values to insert into the database.
 */
function webform_email_reply_insert($data) {
  // need the user replying to the submission
  global $user;

  // simple insert
  db_insert('webform_email_reply')
      ->fields(array(
        'sid' => $data['sid'],
        'nid' => $data['nid'],
        'uid' => $user->uid,
        'replied' => time(),
        'message' => $data['message'],
      ))
      ->execute();
}

/**
 * Check to see if a reply exists already for a submission
 *
 * @param type $nid
 *    The node id of the webform
 * @param type $sid
 *    The submission id
 */
function webform_email_reply_exists($nid, $sid) {

  // Simple db query to get all the emails replies
  $results = db_select('webform_email_reply', 'r')
      ->fields('r')
      ->condition('r.nid', $nid)
      ->condition('r.sid', $sid)
      ->execute()
      ->fetchAll();

  // return what's found, if any
  if ($results) {
    return $results;
  }
  else {
    return NULL;
  }
}

/**
 * Return a table of the email replies to a submission
 *
 * @param type $node
 *    The node of the submission
 * @param type $submissions
 *    The submission
 * @return type
 *    The table of email replies to return
 */
function webform_email_reply_previous($node, $submissions) {

  // Set the header.
  $header = array(
    array('data' => t('#'), 'field' => 'eid', 'sort' => 'desc'),
    array('data' => t('Sent by')),
    array('data' => t('Sent at'), 'field' => 'replied'),
    array('data' => t('Message')),
  );

  // Get the submissions
  // @TODO secodn time this function gets run in a user journey - need to rethink how to store this
  $replies = webform_email_reply_exists($node->nid, $submissions->sid);
  foreach ($replies as $reply) {
    // @TODO find alternative to full user load each time
    $user = user_load($reply->uid);
    $rows[] = array(
      $reply->eid,
      l($user->name, 'user/' . $user->uid),
      date('dS M Y H:i', $reply->replied),
      $reply->message);
  }
  $output = theme('table', array('header' => $header, 'rows' => $rows));
  return $output;
}