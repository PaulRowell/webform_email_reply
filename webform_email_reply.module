<?php

/**
 * @file
 * This module provides a way for users to reply to webform submissions within 
 * the CMS.
 */

/**
 * Implements hook_help().
 */
function webform_email_reply_help($path) {
  $return_value = NULL;
  switch ($path) {
    case "admin/help#webform_email_reply":
      $return_value = "<p>" . t("This module provides a way for users to reply to webform submissions within the CMS.") . '<br />';
      $return_value .= t("Permissions can be set to allow users to reply to all webform submissions or only those on a node the user has created.") . '<p>';
      $return_value .= "<p>" . t("All emails sent are stored in the database and can be viewed from the submission.") . '</p>';
      break;
  }
  return $return_value;
}

/**
 * Implements hook_webform_submission_actions().
 */
function webform_email_reply_webform_submission_actions($node, $submission) {
  if (webform_email_reply_access($node, $submission)) {
    $actions['reply'] = array(
      'title' => t('Email reply'),
      'href' => 'node/' . $node->nid . '/submission/' . $submission->sid . '/reply',
      'query' => drupal_get_destination(),
    );
    // Only display link if there are replies.
    $replies = webform_email_reply_exists($node->nid, $submission->sid);
    if ($replies) {
      // Get number of replies.
      $count = count($replies);
      $actions['previous_replies'] = array(
        'title' => format_plural($count, '1 previous reply', '@count previous replies'),
        'href' => 'node/' . $node->nid . '/submission/' . $submission->sid . '/reply/previous',
        'query' => drupal_get_destination(),
      );
    }
  }
  return $actions;
}

/**
 * Implements hook_menu().
 */
function webform_email_reply_menu() {
  $items = array();

  $items['node/%webform_menu/submission/%webform_menu_submission/reply'] = array(
    'title' => 'Reply to submission',
    'load arguments' => array(1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_email_reply_form', 1, 3),
    'access callback' => 'webform_email_reply_access',
    'access arguments' => array(1, 3),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%webform_menu/submission/%webform_menu_submission/reply/previous'] = array(
    'title' => 'Previous replies to submission',
    'load arguments' => array(1),
    'page callback' => 'webform_email_reply_previous',
    'page arguments' => array(1, 3),
    'access callback' => 'webform_email_reply_access',
    'access arguments' => array(1, 3),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function webform_email_reply_theme() {
  $node = NULL;
  $submissions = array();
  $replies = array();

  return array(
    'webform_replies_table' => array(
      'variables' => array(
        'node' => $node,
        'submissions' => $submissions,
        'replies' => $replies,
      ),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function webform_email_reply_permission() {
  return array(
    'send email replies to all webforms' => array(
      'title' => t('View and send email replies to all webforms'),
      'description' => t('Allows user to view and send emails in reply to any webform. Generally an administrative permission.'),
    ),
    'send email replies to own webforms' => array(
      'title' => t('View and send email replies to own webforms'),
      'description' => t('Allows user to view and send emails in reply to a webform the author has created. Generally an administrative permission.'),
    ),
  );
}

/**
 * A function to check if a user hass access to email reply to a webform.
 *
 * @param object $node
 *   The node for which this webform was submitted.
 * @param object $submission
 *   The submission to email reply to.
 */
function webform_email_reply_access($node, $submission) {
  global $user;
  $account = isset($account) ? $account : $user;

  $reply_all = user_access('send email replies to all webforms', $account);
  $reply_own = isset($submission) && user_access('send email replies to own webforms', $account) && (($account->uid && $account->uid == $submission->uid) || isset($_SESSION['webform_submission'][$submission->sid]));

  return $reply_all || $reply_own;
}

/**
 * Form to send an email reply.
 *
 * @param array $form
 *   The new form array.
 * @param array $form_state
 *   The current form state.
 * @param object $node
 *   The node for which this webform was submitted.
 * @param object $submission
 *   The submission to email reply to (from webform_submitted_data).
 */
function webform_email_reply_form($form, $form_state, $node, $submission) {

  webform_set_breadcrumb($node, $submission);

  // Set the correct page title.
  drupal_set_title(t('Reply to @title', array('@title' => webform_submission_title($node, $submission))));

  // Keep the NID and SID in the same location as the webform_client_form().
  // This helps mollom identify the same fields when deleting a submission.
  $form['#tree'] = TRUE;
  $form['details']['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['details']['sid'] = array(
    '#type' => 'value',
    '#value' => $submission->sid,
  );
  $form['details']['email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email'),
    '#description' => t('The email address(es) to send to. Multiple emails should be seperated by a comma, with no spaces.'),
    '#required' => TRUE,
  );
  $form['details']['subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject'),
    '#default_value' => t('RE: @title', array('@title' => strip_tags($node->title))),
    '#required' => TRUE,
  );
  $form['details']['message'] = array(
    '#type' => 'textarea',
    '#title' => t('Message'),
    '#required' => TRUE,
    '#format' => 'full_html',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Send',
  );
  $form['submission'] = array(
    '#markup' => '<p><h2>' . t('Submission') . '</h2>' . webform_submission_render($node, $submission, NULL, 'html') . '</p>',
  );

  return $form;
}

/**
 * Validation of email reply.
 *
 * @param array $form
 *   The new form array.
 * @param array $form_state
 *   The current form state.
 */
function webform_email_reply_form_validate($form, &$form_state) {
  // Check each email.
  $valid_email = explode(',', $form_state['values']['details']['email']);
  foreach ($valid_email as $email) {
    if (!valid_email_address($email)) {
      form_set_error('details][email', t('The email address, @email, is not valid. Please enter a valid email address.', array('@email' => $email)));
    }
  }
}

/**
 * Confirmation of email reply.
 *
 * @param array $form
 *   The new form array.
 * @param array $form_state
 *   The current form state.
 */
function webform_email_reply_form_submit($form, &$form_state) {

  $nid = $form_state['values']['details']['nid'];
  $sid = $form_state['values']['details']['sid'];

  $emails = explode(',', $form_state['values']['details']['email']);
  $body = $form_state['values']['details']['message'];
  $subject = $form_state['values']['details']['subject'];
  $params = array(
    'body' => $body,
    'subject' => $subject,
  );

  // Send each emails individually.
  foreach ($emails as $email) {
    if (drupal_mail('webform_email_reply', 'message_key', $email, language_default(), $params, $from, TRUE)) {
      drupal_set_message(t('Email sent to @email.', array('@email' => $email)));
      // Insert the values into the database.
      webform_email_reply_insert($form_state['values']['details']);
    }
    else {
      drupal_set_message(t('There was an error sending the email to @email, please contact the site admin.', array('@email' => $email)));
    }
  }
  $form_state['redirect'] = 'node/' . $nid . '/submission/' . $sid;
}

/**
 * Implements hook_mail().
 */
function webform_email_reply_mail($key, &$message, $params) {

  if (isset($params['subject'])) {
    $message['subject'] = $params['subject'];
  }
  if (isset($params['body'])) {
    $message['body'][] = $params['body'];
  }
  if (isset($params['headers']) && is_array($params['headers'])) {
    $message['headers'] += $params['headers'];
  }
}

/**
 * Function to insert the email into the database.
 *
 * @param array $data
 *   The values to insert into the database.
 */
function webform_email_reply_insert($data) {
  // Need the user replying to the submission.
  global $user;

  // Simple insert.
  db_insert('webform_email_reply')
      ->fields(array(
        'sid' => $data['sid'],
        'nid' => $data['nid'],
        'uid' => $user->uid,
        'replied' => time(),
        'message' => $data['message'],
      ))
      ->execute();
}

/**
 * Check to see if a reply exists already for a submission.
 *
 * @param string $nid
 *   The node id of the webform
 * @param string $sid
 *   The submission id
 */
function webform_email_reply_exists($nid, $sid) {

  // Simple db query to get all the emails replies.
  $results = db_select('webform_email_reply', 'r')
      ->fields('r')
      ->condition('r.nid', $nid)
      ->condition('r.sid', $sid)
      ->addTag('node_access')
      ->execute()
      ->fetchAll();

  // Return what's found, if any.
  if ($results) {
    return $results;
  }
  else {
    return NULL;
  }
}

/**
 * Return a table of the email replies to a submission.
 *
 * @param object $node
 *   The node of the submission
 * @param object $submissions
 *   The submission
 * 
 * @return string
 *   The table of email replies to return
 */
function webform_email_reply_previous($node, $submissions) {

  // Set the header.
  $header = array(
    array('data' => t('#'), 'field' => 'eid', 'sort' => 'desc'),
    array('data' => t('Sent by')),
    array('data' => t('Sent at'), 'field' => 'replied'),
    array('data' => t('Message')),
  );

  // Get the submissions.
  // @TODO second time this function gets run in a user journey
  // need to rethink how to store this?
  $replies = webform_email_reply_exists($node->nid, $submissions->sid);
  foreach ($replies as $reply) {
    // @TODO full user load each time, better way of doing this?
    $user = user_load($reply->uid);
    $rows[] = array(
      $reply->eid,
      l($user->name, 'user/' . $user->uid),
      date('dS M Y H:i', $reply->replied),
      $reply->message);
  }
  $output = theme('table', array('header' => $header, 'rows' => $rows));

  return $output;
}
